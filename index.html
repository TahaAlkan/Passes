<!--
MultiSat TLE Finder v4.3.8

Bu s√ºr√ºmde:
‚úÖ Sonu√ßlar artƒ±k filtrelenebilir (isim, min y√ºkseklik, tarih aralƒ±ƒüƒ±)
‚úÖ Her ge√ßi≈üin s√ºresi (dakika) hesaplanƒ±yor
‚úÖ Kolon ba≈ülƒ±klarƒ±na tƒ±klayarak artan/azalan sƒ±ralama yapƒ±labiliyor
‚úÖ CSV dƒ±≈üa aktarƒ±mƒ± bu yeni s√ºtunla birlikte g√ºncel
-->

<!doctype html>
<html lang="en">
<head>
  <link rel="icon" href="data:,">
  <meta charset="utf-8" />
  <title>Passes ‚Äî MultiSat TLE Finder v4.3.0</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #9aa4b2;
      --accent: #3b82f6;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#061226 0%, #071428 100%);
      color:#e6eef8;
      padding:20px;
      -webkit-font-smoothing:antialiased;
    }
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px;flex-wrap:wrap}
    h1{margin:0;font-size:20px}
    p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}
    .card{background:var(--card);padding:16px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(2,6,23,0.6);margin-bottom:16px}
    label{display:block;margin-bottom:6px;font-size:13px;color:var(--muted)}
    input, select, textarea {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:var(--glass);
      color:inherit;
      font-size:13px;
    }
    textarea{min-height:120px;font-family:Menlo,monospace;resize:vertical}
    .row{display:flex;gap:12px}
    .small{font-size:12px;color:var(--muted)}
    button{
      background:var(--accent);color:white;
      padding:10px 14px;border:0;border-radius:8px;
      cursor:pointer;font-weight:600;
    }
    .muted-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left;font-size:13px}
    th{color:var(--muted);font-weight:600;cursor:pointer}
    th:hover{color:var(--accent)}
    .inline{display:inline-flex;align-items:center;gap:8px}
    .top-actions{display:flex;gap:8px;flex-wrap:wrap}
    .footer{color:var(--muted);font-size:13px;margin-top:8px}
    .status{color:var(--muted);font-size:13px;margin-top:6px}
    @media (max-width:720px){.row{flex-direction:column}}
    .suggestions{background:var(--card);border:1px solid rgba(255,255,255,0.05);border-radius:8px;max-height:150px;overflow-y:auto;margin-top:4px}
    .suggestions div{padding:6px 10px;cursor:pointer;font-size:13px}
    .suggestions div:hover{background:var(--glass)}
    .badge{background:var(--glass);border-radius:8px;padding:4px 8px;margin:2px;display:inline-flex;align-items:center;gap:6px}
    .badge .remove{cursor:pointer;color:#f87171}
    .badge .remove:hover{color:#ef4444}
    .loading{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999}
    .loading-box{background:var(--card);padding:20px 30px;border-radius:12px;font-size:14px;color:var(--muted);text-align:center;box-shadow:0 0 20px rgba(0,0,0,0.3)}
    .hidden{display:none}

/* === Mobile fixes === */
.table-wrap{overflow-x:auto; -webkit-overflow-scrolling: touch;} /* horizontal scroll on small screens */

@media (max-width:720px){
  header{flex-direction:column; align-items:flex-start;}
  .top-actions{width:100%; flex-direction:column;}
  .top-actions button{width:100%}

  /* Override inline min/max widths that cause overflow on mobile */
  [style*="min-width:260px"],
  [style*="min-width:220px"]{min-width:0 !important; width:100% !important;}

  [style*="max-width:220px"],
  [style*="max-width:150px"]{max-width:100% !important; width:100% !important;}

  input, select, textarea{width:100%; font-size:14px}

  /* Tables: reduce font size and keep cells in one line (scroll horizontally) */
  table{font-size:12px}
  th,td{padding:8px 10px; white-space:nowrap}
}

    
    #overlapContainer { margin-top: 20px; }

  
/* === Dark/Light theme === */

:root.light {
  --bg: #dfe3e8;
  --card: #f2f4f6;
  --muted: #374151;
  --accent: #4b5563;
  --glass: rgba(0,0,0,0.04);
  color-scheme: light;
}

  --bg: #f6f8fa;
  --card: #ffffff;
  --muted: #4b5563;
  --accent: #2563eb;
  --glass: rgba(0,0,0,0.03);
  color-scheme: light;
}
:root.dark {
  --bg: #1b2431;
  --card: #232e3f;
  --muted: #aeb7c4;
  --accent: #5c9aff;
  --glass: rgba(255,255,255,0.05);
  color-scheme: dark;
}
.theme-toggle {
  background: var(--glass);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 8px;
  padding: 8px 10px;
  cursor: pointer;
  font-size: 16px;
}
.theme-toggle:hover {background: var(--accent); color: white;}
.fade-in {animation: fadeIn 0.6s ease-in;}
@keyframes fadeIn {from{opacity:0;} to{opacity:1;}}


button:hover { opacity: 0.9; }
.muted-btn:hover { background: rgba(0,0,0,0.06); }


/* === Soft Dark Enhancements === */
.card { box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
button:hover { filter: brightness(1.1); }


/* === Settings Panel === */
.settings-btn {
  background: var(--glass);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 8px;
  padding: 8px 10px;
  cursor: pointer;
  font-size: 16px;
}
.settings-btn:hover { background: var(--accent); color: white; }
.settings-panel {
  position: absolute;
  top: 60px;
  right: 20px;
  background: var(--card);
  border-radius: 12px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.4);
  padding: 16px;
  display: none;
  flex-direction: column;
  gap: 10px;
  z-index: 1000;
  width: 220px;
  animation: fadeIn 0.3s ease-in-out;
}
.settings-panel label {
  font-size: 13px;
  color: var(--muted);
}
.settings-panel select {
  background: var(--glass);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  padding: 6px;
  color: inherit;
}


/* === Glassmorphism Settings Panel === */
.settings-btn {
  background: var(--glass);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  padding: 8px 10px;
  cursor: pointer;
  font-size: 16px;
  transition: transform 0.3s ease, background 0.3s ease;
}
.settings-btn:hover {
  transform: rotate(20deg);
  background: var(--accent);
  color: white;
}
.settings-panel {
  position: absolute;
  top: 60px;
  right: 20px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 16px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.4);
  padding: 18px;
  display: none;
  flex-direction: column;
  gap: 12px;
  z-index: 1000;
  width: 240px;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  animation: fadeSlideIn 0.4s ease forwards;
}
.settings-panel label {
  font-size: 13px;
  color: var(--muted);
}
.settings-panel select {
  background: var(--glass);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px;
  padding: 6px;
  color: inherit;
  transition: background 0.3s ease;
}
.settings-panel select:hover {
  background: rgba(255,255,255,0.12);
}
@keyframes fadeSlideIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}


/* === Glass Dashboard Enhancements === */
.card {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 16px;
  box-shadow: 0 8px 25px rgba(0,0,0,0.35);
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}
.card:hover {
  transform: translateY(-3px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
}

/* Filters Section */
#resultsCard .row {
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  padding: 10px;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

/* Results Table */
#resultsContainer table {
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  overflow: hidden;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
#resultsContainer tr:hover {
  background: rgba(255,255,255,0.07);
  transition: background 0.3s ease;
}


/* === Visual Refinement: Glass + Dashboard Enhancements === */

/* General Glass Effect Refinement */
.card {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 16px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  transition: transform 0.25s ease, box-shadow 0.25s ease, background 0.25s ease;
}
.card:hover {
  transform: translateY(-3px);
  background: rgba(255, 255, 255, 0.08);
  box-shadow: 0 10px 28px rgba(0, 0, 0, 0.4);
}

/* Table Styling */
#resultsContainer {
  overflow-x: auto;
  border-radius: 12px;
}
#resultsContainer table {
  border-collapse: collapse;
  width: 100%;
  background: rgba(255, 255, 255, 0.03);
  border-radius: 12px;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
#resultsContainer th {
  position: sticky;
  top: 0;
  background: rgba(15, 23, 36, 0.9);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  z-index: 2;
  color: var(--muted);
}
#resultsContainer tr:hover {
  background: rgba(255,255,255,0.07);
  transition: background 0.3s ease;
}
#resultsContainer td, #resultsContainer th {
  padding: 10px 12px;
}

/* Highlight Max Elevation */
#resultsContainer td:nth-child(4) {
  background: linear-gradient(90deg, rgba(59,130,246,0.1) 0%, rgba(59,130,246,0) 100%);
  border-left: 2px solid rgba(59,130,246,0.3);
}

/* Scrollbar styling */
::-webkit-scrollbar {
  height: 8px;
  width: 8px;
}
::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.1);
  border-radius: 8px;
}
::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.25);
}

/* Light/Dark theme blending */
@media (prefers-color-scheme: light) {
  body {
    background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 100%);
    color: #222;
  }
  .card {
    background: rgba(255, 255, 255, 0.6);
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1);
  }
  th, td {
    color: #222;
  }
}

/* Filter Section Improvements */
#resultsCard .row {
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 10px;
  padding: 12px;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  margin-bottom: 8px;
}
#resultsCard input, #resultsCard button {
  transition: background 0.25s ease, box-shadow 0.25s ease;
}
#resultsCard button:hover {
  background: rgba(59,130,246,0.2);
  box-shadow: 0 0 6px rgba(59,130,246,0.4);
}

/* Mobile improvements */
@media (max-width: 720px) {
  .card {
    padding: 12px;
  }
  .row {
    flex-direction: column;
    gap: 8px;
  }
  button {
    width: 100%;
  }
}


/* === Compact / Expand Table Rows (Mobile) === */
@media (max-width: 720px) {
  #resultsContainer table thead {
    display: none;
  }
  #resultsContainer table, 
  #resultsContainer tbody, 
  #resultsContainer tr, 
  #resultsContainer td {
    display: block;
    width: 100%;
  }
  #resultsContainer tr {
    background: rgba(255,255,255,0.05);
    margin-bottom: 10px;
    border-radius: 10px;
    overflow: hidden;
    transition: background 0.3s ease;
  }
  #resultsContainer td {
    padding: 10px 14px;
    border: none;
  }
  #resultsContainer td::before {
    content: attr(data-label);
    font-weight: 600;
    display: block;
    color: var(--muted);
    margin-bottom: 4px;
  }
  #resultsContainer tr .details {
    display: none;
    padding-top: 4px;
    border-top: 1px solid rgba(255,255,255,0.1);
    margin-top: 4px;
  }
  #resultsContainer tr.expanded .details {
    display: block;
    animation: fadeSlideDown 0.3s ease;
  }
  @keyframes fadeSlideDown {
    from { opacity: 0; transform: translateY(-5px); }
    to { opacity: 1; transform: translateY(0); }
  }
}
<script>
document.addEventListener("click", function(e) {
  if (e.target.closest("#resultsContainer tr")) {
    const row = e.target.closest("#resultsContainer tr");
    row.classList.toggle("expanded");
  }
});
});
</script>


<style>
/* === Map Modal Styles === */
#mapModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
#mapContainer {
  width: 95%;
  height: 90%;
  background: var(--card);
  border-radius: 12px;
  overflow: hidden;
  position: relative;
  box-shadow: 0 0 40px rgba(0,0,0,0.6);
}
#map {
  width: 100%;
  height: 100%;
}
.map-time-controls{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
  background:rgba(6,10,18,0.42);
  border:1px solid rgba(148,163,184,0.35);
  border-radius:999px;
  padding:8px 14px;
  backdrop-filter:blur(8px);
  box-shadow:0 12px 26px rgba(2,6,23,0.35);
  z-index:100003!important;
  color:#e2e8f0;
  font-size:12px;
}
.map-time-label{
  text-transform:uppercase;
  letter-spacing:0.06em;
  font-size:11px;
  color:#cbd5f5;
}
.map-time-row{
  display:flex;
  gap:6px;
  align-items:center;
  min-width:200px;
  flex:1;
}
.map-time-controls input[type="datetime-local"]{
  flex:1;
  background:rgba(15,23,42,0.35);
  border:1px solid rgba(148,163,184,0.35);
  border-radius:10px;
  padding:6px 8px;
  color:#f8fafc;
  font-size:12px;
}
.map-time-controls button{
  background:rgba(59,130,246,0.18);
  color:#bfdbfe;
  border:1px solid rgba(59,130,246,0.35);
  border-radius:10px;
  padding:6px 12px;
  font-size:12px;
  cursor:pointer;
}
.map-time-controls button:hover{
  background:rgba(59,130,246,0.32);
}
.map-time-actions{
  display:flex;
  gap:6px;
}
#mapTimeStatus{
  font-size:11px;
  color:#e0e7ff;
  white-space:nowrap;
}
.map-countdown{
  background:rgba(11,18,32,0.9);
  color:#f8fafc;
  padding:12px 16px;
  border-radius:14px;
  font-size:12px;
  line-height:1.45;
  max-width:320px;
  box-shadow:0 12px 30px rgba(2,6,23,0.55);
  backdrop-filter:blur(8px);
  pointer-events:none;
}
.map-countdown div+div{
  margin-top:4px;
}
.satellite-marker{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  font-size:12px;
  text-align:center;
}
.satellite-marker .satellite-emoji{
  width:36px;
  height:36px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:24px;
  box-shadow:0 4px 14px rgba(0,0,0,0.45);
}
.satellite-marker span{
  font-size:11px;
  font-weight:600;
  color:#e2e8f0;
  background:rgba(2,6,23,0.75);
  padding:2px 8px;
  border-radius:999px;
  white-space:nowrap;
  letter-spacing:0.02em;
}
#closeMapBtn {
  position: absolute;
  top: 10px;
  right: 14px;
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  font-size: 20px;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  cursor: pointer;
  transition: background 0.25s;
}
#closeMapBtn:hover {
  background: rgba(255,255,255,0.2);
}
#mapBtn {
  width:38px;height:38px;border-radius:50%;
  display:flex;align-items:center;justify-content:center;
  background:var(--accent);color:white;font-size:18px;
  transition:transform .25s ease, box-shadow .25s ease;
}
#mapBtn:hover{
  transform:scale(1.08);
  box-shadow:0 0 10px var(--accent);
}
</style>

</style>

<style>
#settingsMenu {
  opacity: 0;
  transform: translateY(-8px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}
#settingsMenu.show {
  opacity: 1;
  transform: translateY(0);
}

<style>
/* === Map Modal Styles === */
#mapModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
#mapContainer {
  width: 95%;
  height: 90%;
  background: var(--card);
  border-radius: 12px;
  overflow: hidden;
  position: relative;
  box-shadow: 0 0 40px rgba(0,0,0,0.6);
}
#map {
  width: 100%;
  height: 100%;
}
#closeMapBtn {
  position: absolute;
  top: 10px;
  right: 14px;
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  font-size: 20px;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  cursor: pointer;
  transition: background 0.25s;
}
#closeMapBtn:hover {
  background: rgba(255,255,255,0.2);
}
#mapBtn {
  width:38px;height:38px;border-radius:50%;
  display:flex;align-items:center;justify-content:center;
  background:var(--accent);color:white;font-size:18px;
  transition:transform .25s ease, box-shadow .25s ease;
}
#mapBtn:hover{
  transform:scale(1.08);
  box-shadow:0 0 10px var(--accent);
}
</style>

</style>


<!-- Leaflet Map Library -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

</head>
<body>
  <div id="utcInfo" style="text-align:center;font-size:14px;color:var(--muted);margin-bottom:12px;">
    üìÖ Loading UTC time...
  </div>

  <div class="container">
    <header>
      <div>
        <h1>Passes ‚Äî MultiSat TLE Finder</h1>
        <p class="lead">Compute satellite passes (SGP4, Fixed UTC start) ‚Äî Multi-satellite & Groups.</p>
      </div>
      <div class="top-actions"><button id="themeToggle" class="theme-toggle">üåô</button>
<button id="settingsBtn" class="settings-btn">‚öôÔ∏è</button>
        <button id="mapBtn" class="muted-btn">üåç </button>
        <button id="computeBtn">Compute Passes</button>
        <button id="downloadCsvBtn" class="muted-btn">Export CSV</button>
        
<div class="dropdown" style="position:relative;">
  <div id="settingsMenu" style="
      position:absolute; right:0; top:110%; z-index:999;
      background:var(--card);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:10px;
      padding:10px;
      box-shadow:0 6px 20px rgba(0,0,0,0.4);
      z-index:100;
      min-width:180px;">
    <label style="display:flex;align-items:center;gap:8px;font-size:13px;">
      <input type="checkbox" id="compactModeToggle" style="transform:scale(1.2);">
      Compact Table Mode
    </label>
<hr style="border:0;border-top:1px solid rgba(255,255,255,0.1);margin:8px 0;">
<label style="display:block;font-size:13px;color:var(--muted);margin-bottom:6px;">Theme Mode</label>
<select id="themeSelect" style="width:100%;padding:6px;border-radius:6px;background:var(--glass);color:inherit;border:1px solid rgba(255,255,255,0.1);">
  <option value="dark">üåë Dark</option>
  <option value="neutral">‚öôÔ∏è Neutral</option>
  <option value="light">‚ö™ Light</option>
</select>

  </div>
</div>

        <button id="clearBtn" class="muted-btn">Clear Results</button>
      </div>
    </header>

<div id="settingsPanel" class="settings-panel">
  <label>Theme</label>
  <select id="themeSelect">
    <option value="dark">Dark</option>
    <option value="light">Light</option>
  </select>
  <label>Animation Speed</label>
  <select id="animSelect">
    <option value="slow">Slow</option>
    <option value="normal" selected>Normal</option>
    <option value="fast">Fast</option>
  </select>
  <label>Table View</label>
  <select id="tableSelect">
    <option value="compact">Compact</option>
    <option value="wide" selected>Wide</option>
  </select>
</div>


    <!-- Search + Group + Loaded TLEs -->
    <section class="card">
      <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap">
        <div style="min-width:260px;flex:1">
          <label>Satellite Search</label>
          <input id="searchBox" type="text" placeholder="Search satellite (e.g., IMECE)">
          <div id="suggestions" class="suggestions"></div>
          <button id="searchBtn" style="margin-top:6px;">Search TLE</button>
          <div class="small">Recent searches stored locally</div>
        </div>

        <div style="min-width:260px;flex:1">
          <label>Or select a group</label>
          <div class="row">
            <select id="groupSelect">
              <option value="">‚Äî Choose a group ‚Äî</option>
              <option value="active">active (all active sats)</option>
              <option value="visual">visual</option>
              <option value="starlink">starlink</option>
              <option value="noaa">noaa</option>
              <option value="weather">weather</option>
              <option value="science">science</option>
              <option value="communications">communications</option>
              <option value="oneweb">oneweb</option>
            </select>
          </div>
          <div class="row" style="margin-top:6px">
            <button id="addGroupBtn">Add Group (first 20)</button>
            <button id="loadGroupAllBtn" class="muted-btn">Load Selected Group (ALL)</button>
          </div>
          <div class="small">Load ALL fetches every satellite in the selected group.</div>
        </div>

        <div style="min-width:260px;flex:1">
          <label>Loaded TLEs</label>
          <textarea id="tleInput" readonly></textarea>
          <div class="small">Automatically managed for selected satellites & groups</div>
        </div>
      </div>
    </section>

    <!-- Active sats + Observer + Settings -->
    <section class="card">
      <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap">
        <div style="min-width:260px;flex:1">
          <label>Active Satellites</label>
          <div id="activeSats" class="small" style="margin-bottom:8px;color:var(--accent)">None loaded</div>
        </div>

        <div style="min-width:260px;flex:1">
          <label>Observer location</label>
          <div class="row" style="margin-bottom:6px">
            <input id="lat" type="text" value="39.9208" placeholder="Latitude">
            <input id="lon" type="text" value="32.8541" placeholder="Longitude">
            <input id="height" type="text" value="850" placeholder="Height (m)">
          </div>
          <div class="small">Default: Ankara ‚Ä¢ Use dot or comma</div>
          <button id="locBtn" class="muted-btn" style="margin-top:6px">Use Current Location</button>
          <div class="small" id="observerCountdownList" style="margin-top:8px;color:var(--accent);display:flex;flex-direction:column;gap:4px;">
            <div>Next contact: ‚Äî</div>
          </div>
        </div>

        <div style="min-width:220px;flex:1">
          <label>Computation settings</label>
          <input id="days" type="number" value="3" min="1">
          <div class="small">Days ahead (UTC)</div>
          <label style="margin-top:8px;">Elevation threshold</label>
          <input id="elThreshold" type="number" value="0" min="0" max="90">
          <div class="small">Elevation limit (0‚Äì90¬∞)</div>
        </div>
      </div>
    </section>

    <!-- Results Section -->
    <section class="card" id="resultsCard">
      <h2 style="margin-top:0">Results</h2>
      <div class="status" id="status">Ready. (SGP4, fixed start time)</div>

      <!-- Filters -->
      <button id="toggleFilterBtn" class="muted-btn" style="margin-bottom:10px;">üîç Show Filters</button>
<div id="filterPanel" class="row" style="margin:10px 0;flex-wrap:wrap;display:none;">
        <input id="filterName" type="text" placeholder="Filter by satellite name" style="flex:1;min-width:160px;">
        <input id="filterMinEl" type="number" placeholder="Min Elevation (¬∞)" style="max-width:150px;">
        <input id="filterStartDate" type="datetime-local" style="max-width:220px;">
        <input id="filterEndDate" type="datetime-local" style="max-width:220px;">
        <button id="applyFilterBtn" class="muted-btn">Apply Filter</button>
        <button id="resetFilterBtn" class="muted-btn">Reset</button>
      </div>

      </div>

<!-- Compact Toggle Button -->
<div id="compactToggleContainer" style="text-align:right; margin-bottom:10px;">
  <button id="toggleCompactBtn" class="muted-btn">üóÇÔ∏è Toggle Compact Mode</button>
</div>

<div id="resultsContainer"></div>
    </section>

    <footer class="footer">
      Built with <a class="link" href="https://github.com/shashwatak/satellite-js" target="_blank">satellite.js</a> (SGP4)
    </footer>
  </div>

  <div id="loadingOverlay" class="loading hidden">
    <div class="loading-box">üîÑ Please wait ‚Äî loading / computing...</div>
  </div>

  <script src="https://unpkg.com/satellite.js@4.1.4/dist/satellite.min.js">
    // --- UTC Info Display ---
    function updateUTCInfo(){
      const now = new Date();
      const startOfYear = new Date(Date.UTC(now.getUTCFullYear(),0,1));
      const dayOfYear = Math.floor((now - startOfYear)/86400000) + 1;
      const iso = now.toISOString().split('.')[0].replace('T',' ');
      document.getElementById('utcInfo').textContent = `üìÖ ${iso} UTC ‚Äî Day ${dayOfYear} of the year`;
    }
    updateUTCInfo();
    setInterval(updateUTCInfo, 1000);

  
    // --- Default filter date initialization ---
    function setDefaultFilterDates(){
      const now = new Date();
      const daysAhead = parseInt(document.getElementById('days').value || '3');
      const end = new Date(now.getTime() + daysAhead * 24 * 3600 * 1000);
      const toLocalInput = d => d.toISOString().slice(0,16);
      document.getElementById('filterStartDate').value = toLocalInput(now);
      document.getElementById('filterEndDate').value = toLocalInput(end);
    }
    document.getElementById('days').addEventListener('input', setDefaultFilterDates);
    window.addEventListener('load', setDefaultFilterDates);

  
    // --- Overlap detection and rendering ---
    function detectOverlaps(passes){
      const overlaps=[];
      for(let i=0;i<passes.length;i++){
        for(let j=i+1;j<passes.length;j++){
          const a=passes[i],b=passes[j];
          const startA=new Date(a.start), endA=new Date(a.end);
          const startB=new Date(b.start), endB=new Date(b.end);
          if(startA<=endB && endA>=startB){ // overlap
            const overlapStart=new Date(Math.max(startA,endB)-endB>0?endB:startB);
            const overlapEnd=new Date(Math.min(endA,endB));
            const durationMs=Math.max(0, overlapEnd - overlapStart);
            const durationStr = new Date(durationMs).toISOString().substr(11,8);
            overlaps.push({
              sat1:a.sat, sat2:b.sat,
              overlapStart:overlapStart,
              overlapEnd:overlapEnd,
              duration:durationStr
            });
          }
        }
      }
      return overlaps;
    }

    function renderOverlaps(passes){
      const overlaps = detectOverlaps(passes);
      if(!overlaps.length){
        document.getElementById('overlapContainer').innerHTML = '<div class="small">No overlapping passes detected.</div>';
        return;
      }
      let h='<h3>Overlapping Passes</h3><table><thead><tr><th>Sat 1</th><th>Sat 2</th><th>Overlap Start</th><th>Overlap End</th><th>Duration</th></tr></thead><tbody>';
      overlaps.forEach(o=>{
        h+=`<tr><td>${o.sat1}</td><td>${o.sat2}</td><td>${formatDate(o.overlapStart)}</td><td>${formatDate(o.overlapEnd)}</td><td>${o.duration}</td></tr>`;
      });
      h+='</tbody></table>';
      document.getElementById('overlapContainer').innerHTML=h;

      // Highlight overlapping rows in main table
      const table = document.querySelector('#resultsTable tbody');
      if(table){
        Array.from(table.rows).forEach(r=>{
          const satName=r.cells[0].textContent;
          if(overlaps.some(o=>o.sat1===satName||o.sat2===satName)){
            r.classList.add('overlap');
          }
        });
      }
    }

    // Extend renderResults to include overlap rendering
    const oldRenderResults = renderResults;
    renderResults = function(passes){
      oldRenderResults(passes);
      if(!document.getElementById('overlapContainer')){
        const div=document.createElement('div');
        div.id='overlapContainer';
        document.getElementById('resultsCard').appendChild(div);
      }
      renderOverlaps(passes);
    }

  

// === Theme Toggle ===
const themeToggle=document.getElementById('themeToggle');
const root=document.documentElement;
const savedTheme=localStorage.getItem('theme')||'dark';
root.classList.add(savedTheme);
themeToggle.textContent=savedTheme==='light'?'üåô':'‚òÄÔ∏è';
themeToggle.onclick=()=>{
  const isLight=root.classList.contains('light');
  root.classList.toggle('light',!isLight);
  root.classList.toggle('dark',isLight);
  const newTheme=isLight?'dark':'light';
  localStorage.setItem('theme',newTheme);
  themeToggle.textContent=newTheme==='light'?'üåô':'‚òÄÔ∏è';
};

// === Filter Accordion ===
const filterBtn=document.getElementById('toggleFilterBtn');
const filterPanel=document.getElementById('filterPanel');
filterBtn.onclick=()=>{
  const open=filterPanel.style.display!=='none';
  filterPanel.style.display=open?'none':'flex';
  filterBtn.textContent=open?'üîç Show Filters':'‚ùå Hide Filters';
};

// === Fade-in Results ===
const origRenderResults = renderResults;
renderResults = function(passes){
  origRenderResults(passes);
  const rc=document.getElementById('resultsContainer');
  rc.classList.remove('fade-in');
  void rc.offsetWidth;
  rc.classList.add('fade-in');
};



// === Settings Panel ===
const settingsBtn = document.getElementById('settingsBtn');
const settingsPanel = document.getElementById('settingsPanel');

settingsBtn.onclick = () => {
  const open = settingsPanel.style.display === 'flex';
  settingsPanel.style.display = open ? 'none' : 'flex';
};

// Restore saved preferences
const savedAnim = localStorage.getItem('animSpeed') || 'normal';
const savedTable = localStorage.getItem('tableView') || 'wide';
document.getElementById('animSelect').value = savedAnim;
document.getElementById('tableSelect').value = savedTable;
document.getElementById('themeSelect').value = savedTheme;

// Apply animation speed
document.documentElement.style.setProperty('--fade-speed',
  savedAnim==='slow'?'1.2s':savedAnim==='fast'?'0.3s':'0.6s'
);

// Handle setting changes
document.getElementById('animSelect').onchange = e => {
  const v=e.target.value;
  localStorage.setItem('animSpeed',v);
  document.documentElement.style.setProperty('--fade-speed',
    v==='slow'?'1.2s':v==='fast'?'0.3s':'0.6s'
  );
};

document.getElementById('tableSelect').onchange = e => {
  const v=e.target.value;
  localStorage.setItem('tableView',v);
  const table=document.getElementById('resultsTable');
  if(table){
    table.style.fontSize=v==='compact'?'12px':'13px';
    table.style.lineHeight=v==='compact'?'1.2':'1.6';
  }
};

document.getElementById('themeSelect').onchange = e => {
  const v=e.target.value;
  root.classList.toggle('light',v==='light');
  root.classList.toggle('dark',v==='dark');
  localStorage.setItem('theme',v);
  themeToggle.textContent=v==='light'?'üåô':'‚òÄÔ∏è';
};

</script>
  <script>
    const searchBox=document.getElementById('searchBox');
    const suggestions=document.getElementById('suggestions');
    const searchBtn=document.getElementById('searchBtn');
    const groupSelect=document.getElementById('groupSelect');
    const addGroupBtn=document.getElementById('addGroupBtn');
    const loadGroupAllBtn=document.getElementById('loadGroupAllBtn');
    const tleInputEl=document.getElementById('tleInput');
    const computeBtn=document.getElementById('computeBtn');
    const clearBtn=document.getElementById('clearBtn');
    const downloadCsvBtn=document.getElementById('downloadCsvBtn');
    const statusEl=document.getElementById('status');
    const resultsContainer=document.getElementById('resultsContainer');
    const latEl=document.getElementById('lat');
    const lonEl=document.getElementById('lon');
    const heightEl=document.getElementById('height');
    const daysEl=document.getElementById('days');
    const elThresholdEl=document.getElementById('elThreshold');
    const locBtn=document.getElementById('locBtn');
    const activeSatsEl=document.getElementById('activeSats');
    const loadingOverlay=document.getElementById('loadingOverlay');
    const observerCountdownListEl=document.getElementById('observerCountdownList');

    const fixedStartUTC=new Date();
    let allSatList=[];
    let tleBank=[];
    let latestPassResults=[];
    let currentSort={key:null,asc:true};
    let observerCountdownTimer=null;
    let observerCountdownItems=[];
    [latEl, lonEl, heightEl].forEach(input=>{
      if(!input) return;
      const notify=()=>resetObserverCountdown('Next contact: observer changed ‚Äî recompute.');
      input.addEventListener('change',notify);
      input.addEventListener('input',notify);
    });

    function showLoading(on){ loadingOverlay.classList.toggle('hidden',!on); }
    function normNum(v){ return parseFloat(String(v).replace(',','.')); }
    function formatDate(d){
      const o=new Date(d);
      const iso=o.toISOString().split('.')[0].replace('T',' ');
      return iso+' UTC';
    }
    function formatDuration(ms){ 
      const totalMs = Math.max(0, ms);
      const hours = String(Math.floor(totalMs / 3600000)).padStart(2, '0');
      const minutes = String(Math.floor((totalMs % 3600000) / 60000)).padStart(2, '0');
      const seconds = String(Math.floor((totalMs % 60000) / 1000)).padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }
    function renderCountdownMessages(messages){
      if(observerCountdownListEl){
        if(!messages.length){
          observerCountdownListEl.innerHTML='<div>Next contact: ‚Äî</div>';
        }else{
          observerCountdownListEl.innerHTML = messages.map(msg=>`<div>${msg}</div>`).join('');
        }
      }
      const cleanMessages = messages.length ? messages : ['Next contact: ‚Äî'];
      const mapMessages = cleanMessages.filter(msg => !/observer changed/i.test(msg));
      const fallbackMapMessages = mapMessages.length ? mapMessages : ['Next contact: ‚Äî'];
      window.latestCountdownMessages = cleanMessages;
      window.latestMapCountdownMessages = fallbackMapMessages;
      if(window.renderMapCountdown){
        window.renderMapCountdown(window.latestMapCountdownMessages);
      }
    }
    function resetObserverCountdown(message='Next contact: ‚Äî'){
      observerCountdownItems=[];
      if(observerCountdownTimer){ clearInterval(observerCountdownTimer); observerCountdownTimer=null; }
      renderCountdownMessages([message]);
    }
    function scheduleObserverCountdown(){
      if(!observerCountdownListEl) return;
      observerCountdownItems=[];
      if(observerCountdownTimer){ clearInterval(observerCountdownTimer); observerCountdownTimer=null; }
      if(!latestPassResults.length){
        renderCountdownMessages(['Next contact: compute passes to preview visibility.']);
        return;
      }
      const now = Date.now();
      const satMap=new Map();
      latestPassResults.forEach(p=>{
        const startTime=new Date(p.start).getTime();
        const endTime=new Date(p.end).getTime();
        if(!Number.isFinite(startTime)||!Number.isFinite(endTime)) return;
        const satData=satMap.get(p.sat)||{active:null,upcoming:null};
        if(now>=startTime && now<=endTime){
          if(!satData.active || endTime<satData.active.end){ satData.active={start:startTime,end:endTime}; }
        }else if(startTime>now){
          if(!satData.upcoming || startTime<satData.upcoming.start){ satData.upcoming={start:startTime,end:endTime}; }
        }
        satMap.set(p.sat,satData);
      });
      tleBank.forEach(s=>{
        if(!satMap.has(s.name)){
          satMap.set(s.name,{active:null,upcoming:null});
        }
      });
      if(!satMap.size){
        renderCountdownMessages(['Next contact: none in current window.']);
        return;
      }
      satMap.forEach((data,sat)=>{
        if(data.active){
          observerCountdownItems.push({sat,type:'active',start:data.active.start,end:data.active.end});
        }else if(data.upcoming){
          observerCountdownItems.push({sat,type:'upcoming',start:data.upcoming.start,end:data.upcoming.end});
        }else{
          observerCountdownItems.push({sat,type:'none'});
        }
      });
      if(!observerCountdownItems.length){
        renderCountdownMessages(['Next contact: none in current window.']);
        return;
      }
      const update=()=>{
        const now=Date.now();
        const messages=[];
        let needsReschedule=false;
        let activeCount=0;
        observerCountdownItems.forEach(item=>{
          if(item.type==='none'){
            messages.push(`${item.sat}: no contact in current window.`);
            return;
          }
          const target=item.type==='active'?item.end:item.start;
          let diff=target-now;
          if(diff<=0){
            if(item.type==='upcoming'){
              item.type='active';
              diff=item.end-now;
              if(diff<=0){
                messages.push(`${item.sat}: pass completed.`);
                needsReschedule=true;
                return;
              }
            }else{
              messages.push(`${item.sat}: pass completed.`);
              needsReschedule=true;
              return;
            }
          }
          if(item.type==='active'){
            activeCount++;
            messages.push(`${item.sat} overhead for ${formatDuration(diff)}`);
          }else{
            messages.push(`Next contact (${item.sat}) in ${formatDuration(diff)}`);
          }
        });
        if(activeCount>1){
          messages.unshift(`Overlapping contact: ${activeCount} satellites overhead.`);
        }
        renderCountdownMessages(messages);
        if(needsReschedule){
          scheduleObserverCountdown();
        }
      };
      update();
      observerCountdownTimer=setInterval(update,1000);
    }
    function dedupePush(entry){ if(!tleBank.some(x=>x.name===entry.name)) tleBank.push(entry); }
    function rebuildTleTextarea(){
      tleInputEl.value = tleBank.length ? tleBank.map(s=>`${s.name}\n${s.tle[0]}\n${s.tle[1]}`).join("\n\n") : '';
    }
    function renderActiveSatellites(){
      if(!tleBank.length){activeSatsEl.textContent='None loaded';return;}
      let html='';
      tleBank.forEach(s=>{
        html+=`<span class="badge">üõ∞Ô∏è ${s.name} <span class="remove" data-name="${s.name}">‚ùå</span></span> `;
      });
      activeSatsEl.innerHTML=html;
      activeSatsEl.querySelectorAll('.remove').forEach(btn=>{
        btn.onclick=()=>{tleBank=tleBank.filter(x=>x.name!==btn.dataset.name);rebuildTleTextarea();renderActiveSatellites();};
      });
    }

    async function loadSatList(){
      try{
        const res=await fetch("https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=TLE");
        const text=await res.text();
        allSatList=text.split(/\r?\n/).filter(l=>l && !l.startsWith("1 ") && !l.startsWith("2 "));
      }catch(e){console.error('sat list fetch error',e);}
    }
    loadSatList();

    searchBox.addEventListener('input',()=>{
      const q=searchBox.value.trim().toUpperCase();
      if(!q){suggestions.innerHTML='';return;}
      const starts=allSatList.filter(s=>s.toUpperCase().startsWith(q));
      const includes=allSatList.filter(s=>s.toUpperCase().includes(q) && !s.toUpperCase().startsWith(q));
      const matches=[...starts,...includes].slice(0,12);
      suggestions.innerHTML=matches.map(m=>`<div>${m}</div>`).join('');
    });
    suggestions.addEventListener('click',e=>{
      if(e.target.tagName==='DIV'){
        searchBox.value=e.target.textContent.trim().replace(/\s+/g,' ');
        suggestions.innerHTML='';
      }
    });

    searchBtn.onclick=async()=>{
      const name=searchBox.value.trim().replace(/\s+/g,' ');
      if(!name){alert("Enter a satellite name");return;}
      showLoading(true);
      try{
        const url=`https://celestrak.org/NORAD/elements/gp.php?NAME=${encodeURIComponent(name)}&FORMAT=TLE&time=${Date.now()}`;
        const res=await fetch(url);
        const text=(await res.text()).trim();
        const lines=text.split(/\r?\n/);
        if(lines.length<2){alert("TLE not found");return;}
        if(lines.length>=3 && !lines[0].startsWith('1 ') && !lines[0].startsWith('2 ')){
          dedupePush({name: lines[0].trim().replace(/\s+/g,' '), tle:[lines[1],lines[2]]});
        }else{
          dedupePush({name, tle:[lines[0],lines[1]]});
        }
        rebuildTleTextarea(); renderActiveSatellites();
        statusEl.textContent=`Added "${name}"`;
      }catch(e){console.error(e);alert('Fetch failed');}
      finally{showLoading(false);}
    };

    async function loadGroup(group, limit){
      showLoading(true);
      try{
        const url=`https://celestrak.org/NORAD/elements/gp.php?GROUP=${encodeURIComponent(group)}&FORMAT=TLE&time=${Date.now()}`;
        const res=await fetch(url);
        const text=(await res.text()).trim();
        const lines=text.split(/\r?\n/);
        let added=0,total=0;
        for(let i=0;i<lines.length;i++){
          const title=lines[i]?.trim(), l1=lines[i+1]?.trim(), l2=lines[i+2]?.trim();
          if(!title||!l1||!l2) break;
          if(l1.startsWith('1 ') && l2.startsWith('2 ')){
            total++;
            const entry={name:title.replace(/\s+/g,' '), tle:[l1,l2], group};
            if(!tleBank.some(x=>x.name===entry.name)){ tleBank.push(entry); added++; }
            i+=2;
            if(limit && added>=limit) break;
          }
        }
        rebuildTleTextarea(); renderActiveSatellites();
        statusEl.textContent=`Loaded ${added}${limit?' (first 20)':''} of ${total} from "${group}".`;
      }catch(e){console.error(e);alert('Group load failed');}
      finally{showLoading(false);}
    }
    addGroupBtn.onclick=()=>{const g=groupSelect.value;if(!g){alert('Choose a group');return;}loadGroup(g,20);};
    loadGroupAllBtn.onclick=()=>{const g=groupSelect.value;if(!g){alert('Choose a group');return;}loadGroup(g,0);};

    function computeLookAngles(satrec,date,obs){
      const gmst=satellite.gstime(date);
      const eci=satellite.propagate(satrec,date);
      if(!eci || !eci.position) return null;
      const ecf=satellite.eciToEcf(eci.position,gmst);
      const look=satellite.ecfToLookAngles({
        longitude:satellite.degreesToRadians(obs.lon),
        latitude:satellite.degreesToRadians(obs.lat),
        height:obs.height/1000
      }, ecf);
      return { el: satellite.radiansToDegrees(look.elevation) };
    }

    async function findPassesForEntry(entry,obs,start,days,elv){
      const end=new Date(start.getTime()+days*24*3600*1000);
      const satrec=satellite.twoline2satrec(entry.tle[0],entry.tle[1]);
      const results=[]; const step=5000;
      let inPass=false, ps=null, maxEl=-Infinity, mt=null;
      for(let t=new Date(start); t<=end; t=new Date(t.getTime()+step)){
        const lk=computeLookAngles(satrec,t,obs);
        if(!lk) continue;
        const el=lk.el;
        if(el>=elv){
          if(!inPass){inPass=true; ps=new Date(t); maxEl=el; mt=new Date(t);}
          else if(el>maxEl){maxEl=el; mt=new Date(t);}
        }else if(inPass){
          results.push({sat:entry.name,start:ps,end:new Date(t-step),maxEl,maxTime:mt,duration:formatDuration(new Date(t-step)-ps)});
          inPass=false;
        }
      }
      if(inPass) results.push({sat:entry.name,start:ps,end:end,maxEl,maxTime:mt,duration:formatDuration(end-ps)});
      return results;
    }

    async function computeAll(obs,days,elv,start=null){
      statusEl.textContent='Computing passes...';
      const startTime=start||fixedStartUTC;
      const all=[];
      for(const entry of tleBank){
        try{ const p=await findPassesForEntry(entry,obs,startTime,days,elv); all.push(...p); }
        catch(e){console.error('compute error',e);}
      }
      all.sort((a,b)=>a.start-b.start);
      statusEl.textContent=`Done ‚Äî ${all.length} pass(es) found.`;
      return all;
    }

    function renderResults(passes){
      latestPassResults=passes;
      if(!passes.length){
        resultsContainer.innerHTML='<div class="small">No passes found.</div>';
        resetObserverCountdown('Next contact: none in current window.');
        return;
      }
      let h='<table id="resultsTable"><thead><tr><th data-key="sat">Satellite</th><th data-key="start">Start</th><th data-key="end">End</th><th data-key="maxEl">Max Elev (¬∞)</th><th data-key="maxTime">Max Time</th><th data-key="durationMin">Duration (min)</th></tr></thead><tbody>';
      for(const x of passes){
        if(!x.start||!x.end||!x.maxTime) continue;
        h+=`<tr><td>${x.sat}</td><td>${formatDate(x.start)}</td><td>${formatDate(x.end)}</td><td>${x.maxEl.toFixed(2)}</td><td>${formatDate(x.maxTime)}</td><td>${x.duration}</td></tr>`;
      }
      h+='</tbody></table>';
      resultsContainer.innerHTML = '<div class="table-wrap">'+h+'</div>';
      document.querySelectorAll('#resultsTable th').forEach(th=>{
        th.onclick=()=>{
          const key=th.dataset.key;
          currentSort.asc=(currentSort.key===key)?!currentSort.asc:true;
          currentSort.key=key;
          const sorted=[...latestPassResults].sort((a,b)=>{
            let av=a[key],bv=b[key];
            if(typeof av==='string')av=av.toUpperCase();
            if(typeof bv==='string')bv=bv.toUpperCase();
            if(!isNaN(av)&&!isNaN(bv)){av=parseFloat(av);bv=parseFloat(bv);}
            if(av<bv)return currentSort.asc?-1:1;
            if(av>bv)return currentSort.asc?1:-1;
            return 0;
          });
          renderResults(sorted);
        };
      });
      scheduleObserverCountdown();
    }
    scheduleObserverCountdown();

    async function runPassComputation(startOverride=null){
      if(!tleBank.length){alert('No satellites/groups loaded');return;}
      const elv=normNum(elThresholdEl.value); if(elv>90){alert('Elevation threshold cannot exceed 90¬∞');return;}
      const obs={lat:normNum(latEl.value),lon:normNum(lonEl.value),height:normNum(heightEl.value)};
      const days=normNum(daysEl.value);
      showLoading(true);
      await new Promise(r=>setTimeout(r,0));
      try{
        const passes=await computeAll(obs,days,elv,startOverride);
        renderResults(passes);
      }
      finally{showLoading(false);}
    }
    computeBtn.onclick=()=>{ runPassComputation(); };

    clearBtn.onclick=()=>{
      showLoading(true);
      try{
        tleBank=[]; latestPassResults=[];
        rebuildTleTextarea(); renderActiveSatellites();
        resultsContainer.innerHTML='';
        const oc=document.getElementById('overlapContainer');
        if(oc){ oc.innerHTML=''; }
        statusEl.textContent='Results cleared.';
        resetObserverCountdown('Next contact: ‚Äî');
      }finally{setTimeout(()=>showLoading(false),150);}
    };

    downloadCsvBtn.onclick=()=>{
      if(!latestPassResults.length){alert('No results to export.');return;}
      showLoading(true);
      try{
        const header='Satellite,Start,End,Max Elev,Max Time,Duration(min)\n';
        const body=latestPassResults.map(p=>`${p.sat},${formatDate(p.start)},${formatDate(p.end)},${p.maxEl.toFixed(2)},${formatDate(p.maxTime)},${p.duration}`).join('\n');
        const blob=new Blob([header+body],{type:'text/csv'});
        const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='passes.csv';document.body.appendChild(a);a.click();a.remove();
      }finally{setTimeout(()=>showLoading(false),200);}
    };

    locBtn.onclick=()=>{
      if(!navigator.geolocation){alert('Geolocation not supported');return;}
      showLoading(true);
      navigator.geolocation.getCurrentPosition(pos=>{
        latEl.value=pos.coords.latitude.toFixed(4);
        lonEl.value=pos.coords.longitude.toFixed(4);
        heightEl.value=(pos.coords.altitude||0).toFixed(0);
        if(window.refreshObserverCoverage){ window.refreshObserverCoverage(); }
        resetObserverCountdown('Next contact: observer changed ‚Äî recompute.');
        showLoading(false);
      },e=>{alert('Could not get location: '+e.message);showLoading(false);});
    };

    document.getElementById('applyFilterBtn').onclick=()=>{
      const name=document.getElementById('filterName').value.trim().toUpperCase();
      const minEl=parseFloat(document.getElementById('filterMinEl').value)||0;
      const startStr=document.getElementById('filterStartDate').value;
      const endStr=document.getElementById('filterEndDate').value;
      const startFilter=startStr?new Date(startStr):null;
      const endFilter=endStr?new Date(endStr):null;
      const filtered=latestPassResults.filter(p=>{
        const sTime=new Date(p.start);
        return (!name||p.sat.toUpperCase().includes(name))&&p.maxEl>=minEl&&(!startFilter||sTime>=startFilter)&&(!endFilter||sTime<=endFilter);
      });
      renderResults(filtered);
      statusEl.textContent=`Filtered ${filtered.length} pass(es).`;
    };

    document.getElementById('resetFilterBtn').onclick=()=>{
      document.getElementById('filterName').value='';
      document.getElementById('filterMinEl').value='';
      document.getElementById('filterStartDate').value='';
      document.getElementById('filterEndDate').value='';
      renderResults(latestPassResults);
      statusEl.textContent=`Showing all ${latestPassResults.length} pass(es).`;
    };
  
    // --- UTC Info Display ---
    function updateUTCInfo(){
      const now = new Date();
      const startOfYear = new Date(Date.UTC(now.getUTCFullYear(),0,1));
      const dayOfYear = Math.floor((now - startOfYear)/86400000) + 1;
      const iso = now.toISOString().split('.')[0].replace('T',' ');
      document.getElementById('utcInfo').textContent = `üìÖ ${iso} UTC ‚Äî Day ${dayOfYear} of the year`;
    }
    updateUTCInfo();
    setInterval(updateUTCInfo, 1000);

  
    // --- Default filter date initialization ---
    function setDefaultFilterDates(){
      const now = new Date();
      const daysAhead = parseInt(document.getElementById('days').value || '3');
      const end = new Date(now.getTime() + daysAhead * 24 * 3600 * 1000);
      const toLocalInput = d => d.toISOString().slice(0,16);
      document.getElementById('filterStartDate').value = toLocalInput(now);
      document.getElementById('filterEndDate').value = toLocalInput(end);
    }
    document.getElementById('days').addEventListener('input', setDefaultFilterDates);
    window.addEventListener('load', setDefaultFilterDates);

  
    // --- Overlap detection and rendering ---
    function detectOverlaps(passes){
      const overlaps=[];
      for(let i=0;i<passes.length;i++){
        for(let j=i+1;j<passes.length;j++){
          const a=passes[i],b=passes[j];
          const startA=new Date(a.start), endA=new Date(a.end);
          const startB=new Date(b.start), endB=new Date(b.end);
          if(startA<=endB && endA>=startB){ // overlap
            const overlapStart=new Date(Math.max(startA,endB)-endB>0?endB:startB);
            const overlapEnd=new Date(Math.min(endA,endB));
            const durationMs=Math.max(0, overlapEnd - overlapStart);
            const durationStr = new Date(durationMs).toISOString().substr(11,8);
            overlaps.push({
              sat1:a.sat, sat2:b.sat,
              overlapStart:overlapStart,
              overlapEnd:overlapEnd,
              duration:durationStr
            });
          }
        }
      }
      return overlaps;
    }

    function renderOverlaps(passes){
      const overlaps = detectOverlaps(passes);
      if(!overlaps.length){
        document.getElementById('overlapContainer').innerHTML = '<div class="small">No overlapping passes detected.</div>';
        return;
      }
      let h='<h3>Overlapping Passes</h3><table><thead><tr><th>Sat 1</th><th>Sat 2</th><th>Overlap Start</th><th>Overlap End</th><th>Duration</th></tr></thead><tbody>';
      overlaps.forEach(o=>{
        h+=`<tr><td>${o.sat1}</td><td>${o.sat2}</td><td>${formatDate(o.overlapStart)}</td><td>${formatDate(o.overlapEnd)}</td><td>${o.duration}</td></tr>`;
      });
      h+='</tbody></table>';
      document.getElementById('overlapContainer').innerHTML=h;

      // Highlight overlapping rows in main table
      const table = document.querySelector('#resultsTable tbody');
      if(table){
        Array.from(table.rows).forEach(r=>{
          const satName=r.cells[0].textContent;
          if(overlaps.some(o=>o.sat1===satName||o.sat2===satName)){
            r.classList.add('overlap');
          }
        });
      }
    }

    // Extend renderResults to include overlap rendering
    const oldRenderResults = renderResults;
    renderResults = function(passes){
      oldRenderResults(passes);
      if(!document.getElementById('overlapContainer')){
        const div=document.createElement('div');
        div.id='overlapContainer';
        document.getElementById('resultsCard').appendChild(div);
      }
      renderOverlaps(passes);
    }

  

// === Theme Toggle ===
const themeToggle=document.getElementById('themeToggle');
const root=document.documentElement;
const savedTheme=localStorage.getItem('theme')||'dark';
root.classList.add(savedTheme);
themeToggle.textContent=savedTheme==='light'?'üåô':'‚òÄÔ∏è';
themeToggle.onclick=()=>{
  const isLight=root.classList.contains('light');
  root.classList.toggle('light',!isLight);
  root.classList.toggle('dark',isLight);
  const newTheme=isLight?'dark':'light';
  localStorage.setItem('theme',newTheme);
  themeToggle.textContent=newTheme==='light'?'üåô':'‚òÄÔ∏è';
};

// === Filter Accordion ===
const filterBtn=document.getElementById('toggleFilterBtn');
const filterPanel=document.getElementById('filterPanel');
filterBtn.onclick=()=>{
  const open=filterPanel.style.display!=='none';
  filterPanel.style.display=open?'none':'flex';
  filterBtn.textContent=open?'üîç Show Filters':'‚ùå Hide Filters';
};

// === Fade-in Results ===
const origRenderResults = renderResults;
renderResults = function(passes){
  origRenderResults(passes);
  const rc=document.getElementById('resultsContainer');
  rc.classList.remove('fade-in');
  void rc.offsetWidth;
  rc.classList.add('fade-in');
};



// === Settings Panel ===
const settingsBtn = document.getElementById('settingsBtn');
const settingsPanel = document.getElementById('settingsPanel');

settingsBtn.onclick = () => {
  const open = settingsPanel.style.display === 'flex';
  settingsPanel.style.display = open ? 'none' : 'flex';
};

// Restore saved preferences
const savedAnim = localStorage.getItem('animSpeed') || 'normal';
const savedTable = localStorage.getItem('tableView') || 'wide';
document.getElementById('animSelect').value = savedAnim;
document.getElementById('tableSelect').value = savedTable;
document.getElementById('themeSelect').value = savedTheme;

// Apply animation speed
document.documentElement.style.setProperty('--fade-speed',
  savedAnim==='slow'?'1.2s':savedAnim==='fast'?'0.3s':'0.6s'
);

// Handle setting changes
document.getElementById('animSelect').onchange = e => {
  const v=e.target.value;
  localStorage.setItem('animSpeed',v);
  document.documentElement.style.setProperty('--fade-speed',
    v==='slow'?'1.2s':v==='fast'?'0.3s':'0.6s'
  );
};

document.getElementById('tableSelect').onchange = e => {
  const v=e.target.value;
  localStorage.setItem('tableView',v);
  const table=document.getElementById('resultsTable');
  if(table){
    table.style.fontSize=v==='compact'?'12px':'13px';
    table.style.lineHeight=v==='compact'?'1.2':'1.6';
  }
};

document.getElementById('themeSelect').onchange = e => {
  const v=e.target.value;
  root.classList.toggle('light',v==='light');
  root.classList.toggle('dark',v==='dark');
  localStorage.setItem('theme',v);
  themeToggle.textContent=v==='light'?'üåô':'‚òÄÔ∏è';
};

</script>

<script>
let compactMode = false;

function applyCompactMode() {
  const table = document.querySelector("#resultsContainer table");
  if (!table) return;
  if (compactMode) {
    table.classList.add("compact");
  } else {
    table.classList.remove("compact");
  }
}

document.getElementById("toggleCompactBtn").addEventListener("click", () => {
  compactMode = !compactMode;
  applyCompactMode();
});

// Style adjustments for compact mode (desktop)
const style = document.createElement("style");
style.textContent = `
  #resultsContainer table.compact thead {
    display: none;
  }
  #resultsContainer table.compact tr {
    display: block;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    margin-bottom: 8px;
    padding: 6px 8px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #resultsContainer table.compact td {
    display: block;
    border: none;
    padding: 8px 10px;
  }
  #resultsContainer table.compact td::before {
    content: attr(data-label);
    font-weight: 600;
    display: block;
    color: var(--muted);
    margin-bottom: 2px;
  }
  #resultsContainer table.compact tr:hover {
    background: rgba(255,255,255,0.08);
  }
  #resultsContainer table.compact tr .details {
    display: none;
  }
  #resultsContainer table.compact tr.expanded .details {
    display: block;
  }
`;
document.head.appendChild(style);
</script>


<script>
document.addEventListener("DOMContentLoaded", function() {
// Settings dropdown toggle
const settingsBtn = document.getElementById("settingsBtn");
const settingsMenu = document.getElementById("settingsMenu");
settingsBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  settingsMenu.classList.toggle("show");
});
document.addEventListener("click", (e) => {
  if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
    settingsMenu.classList.add("hidden");
  }
});

// Compact Mode logic
const compactToggle = document.getElementById("compactModeToggle");
compactToggle.addEventListener("change", () => {
  const table = document.querySelector("#resultsContainer table");
  if (!table) return;
  if (compactToggle.checked) {
    table.classList.add("compact");
  } else {
    table.classList.remove("compact");
  }
});

// Add compact mode style for desktop
const style = document.createElement("style");
style.textContent = `
  #resultsContainer table.compact thead {
    display: none;
  }
  #resultsContainer table.compact tr {
    display: block;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    margin-bottom: 8px;
    padding: 6px 8px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #resultsContainer table.compact td {
    display: block;
    border: none;
    padding: 8px 10px;
  }
  #resultsContainer table.compact td::before {
    content: attr(data-label);
    font-weight: 600;
    display: block;
    color: var(--muted);
    margin-bottom: 2px;
  }
  #resultsContainer table.compact tr:hover {
    background: rgba(255,255,255,0.08);
  }
  #resultsContainer table.compact tr .details {
    display: none;
  }
  #resultsContainer table.compact tr.expanded .details {
    display: block;
  }
`;
document.head.appendChild(style);
});
</script>


<script>
// Theme system
const themeSelectControl = document.getElementById("themeSelect");

// Load saved theme
const storedThemeMode = localStorage.getItem("themeMode") || "dark";
applyTheme(storedThemeMode);
if (themeSelectControl) themeSelectControl.value = storedThemeMode;

// Theme change handler
if (themeSelectControl) {
  themeSelectControl.addEventListener("change", () => {
    const theme = themeSelectControl.value;
    localStorage.setItem("themeMode", theme);
    applyTheme(theme);
  });
}

function applyTheme(theme) {
  const root = document.documentElement;
  if (theme === "dark") {
    root.style.setProperty("--bg", "#0f1724");
    root.style.setProperty("--card", "#0b1220");
    root.style.setProperty("--muted", "#9aa4b2");
    root.style.setProperty("--accent", "#3b82f6");
    root.style.setProperty("--glass", "rgba(255,255,255,0.03)");
    document.body.style.background = "linear-gradient(180deg,#061226 0%, #071428 100%)";
  } else if (theme === "neutral") {
    root.style.setProperty("--bg", "#dcdfe3");
    root.style.setProperty("--card", "#f3f4f6");
    root.style.setProperty("--muted", "#6b7280");
    root.style.setProperty("--accent", "#6366f1");
    root.style.setProperty("--glass", "rgba(255,255,255,0.6)");
    document.body.style.background = "linear-gradient(180deg,#e5e7eb 0%, #d1d5db 100%)";
  } else if (theme === "light") {
    root.style.setProperty("--bg", "#f8fafc");
    root.style.setProperty("--card", "#ffffff");
    root.style.setProperty("--muted", "#64748b");
    root.style.setProperty("--accent", "#2563eb");
    root.style.setProperty("--glass", "rgba(255,255,255,0.7)");
    document.body.style.background = "linear-gradient(180deg,#f9fafb 0%, #f1f5f9 100%)";
  }
}
</script>


<!-- === Map Modal === -->



<script>
window.addEventListener('DOMContentLoaded', () => {
  const mapModal = document.getElementById('mapModal');
  const mapBtn = document.getElementById('mapBtn');
  const closeMapBtn = document.getElementById('closeMapBtn');
  const latInput = document.getElementById('lat');
  const lonInput = document.getElementById('lon');
  const heightInput = document.getElementById('height');
  const elevationThresholdInput = document.getElementById('elThreshold');
  const mapTimeInput = document.getElementById('mapTimeInput');
  const mapJumpBtn = document.getElementById('mapJumpBtn');
  const mapNowBtn = document.getElementById('mapNowBtn');
  const mapPlayBtn = document.getElementById('mapPlayBtn');
  const mapTimeStatus = document.getElementById('mapTimeStatus');
  let mapInstance;
  let baseLayers;
  const markers = {};
  const groundTracks = {};
  const satelliteAltitudes = {};
  let observerCircle;
  let countdownControl;
  let countdownControlDiv;
  let trackAnimationTimer = null;
  const TRACK_HORIZON_FUTURE_MIN = 90;
  const TRACK_HORIZON_PAST_MIN = 30;
  const TRACK_STEP_MIN = 3;
  const TRACK_ANIMATION_INTERVAL_MS = 600;
  const TRACK_DASH_SPEED = 4;
  const TRACK_DASH_ARRAY = '14 8';
  const LIVE_TRACK_REFRESH_THRESHOLD_MS = 60000;
  let trackReferenceDate = new Date();
  let mapTimeMode = 'live'; // 'live' or 'sim'
  let mapSimTime = null;
  let mapSimPlaying = false;
  const MAP_SIM_STEP_MS = 1000;
  let wheelDeltaBuffer = 0;
  let wheelResetTimer = null;
  const wheelThreshold = 120;
  const SAT_COLOR_PALETTE = [
    '#38bdf8','#f97316','#a855f7','#22d3ee','#f472b6',
    '#4ade80','#facc15','#fb7185','#c084fc','#34d399',
    '#60a5fa','#f87171','#fbbf24','#2dd4bf','#f472b6'
  ];
  const satColorCache = {};
  window.latestCountdownMessages = window.latestCountdownMessages || ['Next contact: ‚Äî'];
  window.latestMapCountdownMessages = window.latestMapCountdownMessages || ['Next contact: ‚Äî'];
  const onWheel = e => {
    e.preventDefault();
    wheelDeltaBuffer += e.deltaY;
    if (wheelResetTimer) clearTimeout(wheelResetTimer);
    wheelResetTimer = setTimeout(() => {
      wheelDeltaBuffer = 0;
      wheelResetTimer = null;
    }, 200);
    if (Math.abs(wheelDeltaBuffer) >= wheelThreshold) {
      if (wheelDeltaBuffer > 0) {
        mapInstance.zoomOut();
      } else {
        mapInstance.zoomIn();
      }
      wheelDeltaBuffer = 0;
    }
  };
  const parseCoord = input => {
    if (!input) return null;
    const value = parseFloat(String(input.value).replace(',', '.'));
    return Number.isFinite(value) ? value : null;
  };
  const toRadians = deg => (deg * Math.PI) / 180;
  const getAverageSatAltitudeKm = () => {
    const values = Object.values(satelliteAltitudes).filter(v => Number.isFinite(v) && v > 0);
    if (!values.length) return 550;
    return values.reduce((sum, val) => sum + val, 0) / values.length;
  };
  const elevationFromPsi = (psi, satAltKm) => {
    const R = 6371;
    const h = Math.max(0, satAltKm);
    const numerator = (R + h) * Math.cos(psi) - R;
    const denominator = Math.sqrt((R + h) * (R + h) + R * R - 2 * R * (R + h) * Math.cos(psi));
    const sinE = numerator / denominator;
    return Math.asin(Math.max(-1, Math.min(1, sinE)));
  };
  const solveGroundRange = (satAltKm, elevRad) => {
    const R = 6371;
    const target = Math.max(0, Math.min(Math.PI / 2 - 0.0001, elevRad));
    let low = 0;
    let high = Math.PI / 2 - 0.0001;
    for (let i = 0; i < 40; i++) {
      const mid = (low + high) / 2;
      const elev = elevationFromPsi(mid, satAltKm);
      if (elev > target) {
        low = mid;
      } else {
        high = mid;
      }
    }
    return R * ((low + high) / 2) * 1000;
  };
  const computeObserverRadius = () => {
    const minElevDeg = parseFloat(String(elevationThresholdInput?.value || 0).replace(',', '.')) || 0;
    const elevRad = toRadians(Math.min(Math.max(minElevDeg, 0), 89.9));
    const avgAltKm = getAverageSatAltitudeKm();
    return solveGroundRange(avgAltKm, elevRad);
  };
  const getObserverLocation = () => {
    const lat = parseCoord(latInput);
    const lon = parseCoord(lonInput);
    const heightMeters = parseFloat(String(heightInput?.value || 0).replace(',', '.')) || 0;
    return { lat, lon, height: heightMeters };
  };
  const updateObserverCoverage = () => {
    if (!mapInstance) return;
    const { lat, lon } = getObserverLocation();
    if (lat === null || lon === null) {
      if (observerCircle) {
        mapInstance.removeLayer(observerCircle);
        observerCircle = null;
      }
      return;
    }
    const radiusMeters = computeObserverRadius();
    const latLng = [lat, lon];
    const circleOptions = {
      radius: radiusMeters,
      color: '#f97316',
      weight: 2.5,
      dashArray: '8 6',
      fillColor: '#f97316',
      fillOpacity: 0.06,
      opacity: 0.95
    };
    if (!observerCircle) {
      observerCircle = L.circle(latLng, circleOptions).addTo(mapInstance);
    } else {
      observerCircle.setLatLng(latLng);
      observerCircle.setRadius(radiusMeters);
      observerCircle.setStyle(circleOptions);
    }
  };
  window.refreshObserverCoverage = updateObserverCoverage;
  const pad2 = v => (v < 10 ? `0${v}` : `${v}`);
  const formatForInput = date => {
    if (!date) return '';
    return date.toISOString().slice(0,19);
  };
  const setMapTimeInputValue = date => {
    if (mapTimeInput && date) {
      mapTimeInput.value = formatForInput(date);
    }
  };
  const parseMapTimeInput = () => {
    if (!mapTimeInput || !mapTimeInput.value) return null;
    const parsed = new Date(mapTimeInput.value + 'Z');
    return isNaN(parsed.getTime()) ? null : parsed;
  };
  const updatePlayButton = () => {
    if (!mapPlayBtn) return;
    mapPlayBtn.textContent = mapSimPlaying ? '‚è∏ Pause' : '‚ñ∂Ô∏è Play';
  };
  const updateMapTimeStatus = (displayDate = null) => {
    if (!mapTimeStatus) return;
    if (mapTimeMode === 'live') {
      mapTimeStatus.textContent = 'Live mode';
      return;
    }
    const label = mapSimPlaying ? 'Playing' : 'Paused';
    const timestamp = displayDate ? displayDate.toUTCString() : '‚Äî';
    mapTimeStatus.textContent = `${label} @ ${timestamp}`;
  };
  const setLiveMode = () => {
    const now = new Date();
    mapTimeMode = 'live';
    mapSimPlaying = false;
    mapSimTime = null;
    setMapTimeInputValue(now);
    updatePlayButton();
    updateMapTimeStatus(now);
    rebuildAllGroundTracks(now);
  };
  const setSimulatedTime = (date, play=false) => {
    const target = new Date(date);
    mapTimeMode = 'sim';
    mapSimTime = new Date(target);
    mapSimPlaying = !!play;
    setMapTimeInputValue(mapSimTime);
    updatePlayButton();
    updateMapTimeStatus(mapSimTime);
    rebuildAllGroundTracks(mapSimTime);
  };
  const togglePlayState = () => {
    if (mapTimeMode === 'live') {
      mapSimTime = new Date();
      mapTimeMode = 'sim';
      mapSimPlaying = true;
      setMapTimeInputValue(mapSimTime);
      rebuildAllGroundTracks(mapSimTime);
    } else {
      mapSimPlaying = !mapSimPlaying;
    }
    updatePlayButton();
    updateMapTimeStatus(mapSimTime);
  };
  const getEffectiveMapTime = () => {
    if (mapTimeMode === 'live') {
      updateMapTimeStatus(new Date());
      return new Date();
    }
    if (!mapSimTime) mapSimTime = new Date();
    if (mapSimPlaying) {
      mapSimTime = new Date(mapSimTime.getTime() + MAP_SIM_STEP_MS);
      setMapTimeInputValue(mapSimTime);
    }
    updateMapTimeStatus(mapSimTime);
    return new Date(mapSimTime);
  };
  const ensureMapTimeInputDefault = () => {
    if (mapTimeInput && !mapTimeInput.value) {
      setMapTimeInputValue(new Date());
    }
  };
  const getSatColor = name => {
    if (satColorCache[name]) return satColorCache[name];
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = (hash + name.charCodeAt(i) * 31) >>> 0;
    }
    const color = SAT_COLOR_PALETTE[hash % SAT_COLOR_PALETTE.length];
    satColorCache[name] = color;
    return color;
  };
  const getSatelliteIcon = (name, color) => L.divIcon({
    className: 'satellite-marker',
    html: `<div class="satellite-emoji" style="color:${color};border:2px solid ${color};background:${color}22;">üõ∞Ô∏è</div><span style="color:${color};">${name}</span>`,
    iconSize: [32, 42],
    iconAnchor: [16, 20],
    popupAnchor: [0, -20]
  });
  const rebuildAllGroundTracks = (referenceDate = new Date()) => {
    trackReferenceDate = new Date(referenceDate);
    Object.keys(groundTracks).forEach(name => {
      groundTracks[name].layers.forEach(layer => {
        if (mapInstance) mapInstance.removeLayer(layer);
      });
      delete groundTracks[name];
    });
    if (!mapInstance || !tleBank.length) return;
    tleBank.forEach(s => {
      try {
        const rec = satellite.twoline2satrec(s.tle[0], s.tle[1]);
        const color = getSatColor(s.name);
        refreshGroundTrack(s.name, rec, color);
      } catch (err) {
        /* ignore bad TLE entries */
      }
    });
  };
  const animateTrackDashes = () => {
    Object.keys(groundTracks).forEach(name => {
      const track = groundTracks[name];
      if (!track) return;
      track.dashOffset = (track.dashOffset || 0) - TRACK_DASH_SPEED;
      track.layers.forEach(layer => {
        layer.setStyle({ dashOffset: `${track.dashOffset}` });
      });
    });
  };
  const ensureTrackAnimation = () => {
    if (trackAnimationTimer) return;
    trackAnimationTimer = setInterval(animateTrackDashes, TRACK_ANIMATION_INTERVAL_MS);
  };
  ensureTrackAnimation();
  setLiveMode();
  const ensureCountdownControl = () => {
    if (!mapInstance || countdownControl) return;
    countdownControl = L.control({ position: 'bottomleft' });
    countdownControl.onAdd = function () {
      countdownControlDiv = L.DomUtil.create('div', 'map-countdown');
      countdownControlDiv.innerHTML = '<div>Next contact: ‚Äî</div>';
      return countdownControlDiv;
    };
    countdownControl.addTo(mapInstance);
    if (window.latestMapCountdownMessages) {
      renderCountdownOnMap(window.latestMapCountdownMessages);
    }
  };
  const renderCountdownOnMap = (messages = []) => {
    if (!countdownControlDiv) return;
    if (!messages.length) {
      countdownControlDiv.innerHTML = '<div>Next contact: ‚Äî</div>';
      return;
    }
    countdownControlDiv.innerHTML = messages.map(msg => `<div>${msg}</div>`).join('');
  };
  window.renderMapCountdown = messages => {
    ensureCountdownControl();
    renderCountdownOnMap(messages && messages.length ? messages : ['Next contact: ‚Äî']);
  };
  const buildGroundTrackSegments = (rec, startDate) => {
    const segments = [];
    let currentSegment = [];
    let prevLon = null;
    const startMinutes = -TRACK_HORIZON_PAST_MIN;
    const endMinutes = TRACK_HORIZON_FUTURE_MIN;
    for (let minutes = startMinutes; minutes <= endMinutes; minutes += TRACK_STEP_MIN) {
      const sampleDate = new Date(startDate.getTime() + minutes * 60000);
      const pos = satellite.propagate(rec, sampleDate);
      if (!pos.position) continue;
      const gmst = satellite.gstime(sampleDate);
      const geo = satellite.eciToGeodetic(pos.position, gmst);
      const lat = satellite.degreesLat(geo.latitude);
      const lon = satellite.degreesLong(geo.longitude);
      if (!isFinite(lat) || !isFinite(lon)) continue;
      if (prevLon !== null && Math.abs(lon - prevLon) > 180) {
        if (currentSegment.length) segments.push(currentSegment);
        currentSegment = [];
      }
      currentSegment.push([lat, lon]);
      prevLon = lon;
    }
    if (currentSegment.length) segments.push(currentSegment);
    return segments;
  };

  const refreshGroundTrack = (name, rec, color) => {
    if (!mapInstance) return;
    const prevOffset = groundTracks[name]?.dashOffset || 0;
    if (groundTracks[name]) {
      groundTracks[name].layers.forEach(layer => mapInstance.removeLayer(layer));
    }
    const segments = buildGroundTrackSegments(rec, trackReferenceDate);
    const layers = segments.map(segment => L.polyline(segment, {
      color,
      weight: 2.4,
      opacity: 0.95,
      dashArray: TRACK_DASH_ARRAY,
      lineCap: 'round',
      lineJoin: 'round',
      dashOffset: prevOffset
    }).addTo(mapInstance));
    groundTracks[name] = { layers, dashOffset: prevOffset, lastComputed: Date.now() };
  };

  const ensureMap = () => {
    if (!mapInstance) {
      mapInstance = L.map('map', {
        worldCopyJump: true,
      }).setView([0, 0], 2);

      const streetLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '¬© OpenStreetMap'
      }).addTo(mapInstance);

      const satelliteImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Tiles ¬© Esri ‚Äî Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
      });
      const satelliteLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Labels ¬© Esri'
      });
      const satelliteLayer = L.layerGroup([satelliteImagery, satelliteLabels]);

      baseLayers = {
        'Street': streetLayer,
        'Satellite': satelliteLayer
      };

      L.control.layers(baseLayers, null, { position: 'topleft' }).addTo(mapInstance);

      mapInstance.scrollWheelZoom.disable();
      mapInstance.getContainer().addEventListener('wheel', onWheel, { passive:false });
      window.map = mapInstance;
    }
    mapInstance.invalidateSize();
    updateObserverCoverage();
    ensureCountdownControl();
    if (countdownControlDiv && window.latestMapCountdownMessages) {
      renderCountdownOnMap(window.latestMapCountdownMessages);
    }
    ensureMapTimeInputDefault();
  };

  const showMap = () => {
    if (!mapModal) return;
    mapModal.style.display = 'flex';
    mapModal.style.opacity = '1';
    mapModal.style.visibility = 'visible';
    mapModal.style.zIndex = '999999';
    setTimeout(async ()=>{
      ensureMap();
      const override = (mapTimeMode==='sim' && mapSimTime)? new Date(mapSimTime): null;
      await runPassComputation(override);
    }, 400);
  };

  const hideMap = () => {
    if (!mapModal) return;
    mapModal.style.opacity = '0';
    mapModal.style.visibility = 'hidden';
    setTimeout(() => {
      mapModal.style.display = 'none';
    }, 300);
  };

  if (mapBtn) mapBtn.addEventListener('click', showMap);
  if (closeMapBtn) closeMapBtn.addEventListener('click', hideMap);
  if (mapJumpBtn) {
    mapJumpBtn.addEventListener('click', () => {
      const target = parseMapTimeInput();
      if (!target) {
        alert('Please select a valid date/time.');
        return;
      }
      setSimulatedTime(target, false);
      runPassComputation(target);
    });
  }
  if (mapNowBtn) {
    mapNowBtn.addEventListener('click', () => {
      setLiveMode();
      runPassComputation();
    });
  }
  if (mapPlayBtn) {
    mapPlayBtn.addEventListener('click', togglePlayState);
  }
  [latInput, lonInput].forEach(input => {
    if (!input) return;
    const handler = () => updateObserverCoverage();
    input.addEventListener('input', handler);
    input.addEventListener('change', handler);
  });
  [heightInput, elevationThresholdInput].forEach(input => {
    if (!input) return;
    const handler = () => updateObserverCoverage();
    input.addEventListener('input', handler);
    input.addEventListener('change', handler);
  });
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') hideMap();
  });

  function updateSatelliteMarkers() {
    if (!tleBank.length || !mapInstance) return;
    const effectiveTime = getEffectiveMapTime();
    if (mapTimeMode === 'live' && Math.abs(effectiveTime.getTime() - trackReferenceDate.getTime()) > LIVE_TRACK_REFRESH_THRESHOLD_MS) {
      rebuildAllGroundTracks(effectiveTime);
    }
    const activeNames = new Set();
    tleBank.forEach(s => {
      try {
        const rec = satellite.twoline2satrec(s.tle[0], s.tle[1]);
        const pos = satellite.propagate(rec, effectiveTime);
        if (!pos.position) return;
        const gmst = satellite.gstime(effectiveTime);
        const geo = satellite.eciToGeodetic(pos.position, gmst);
        const lat = satellite.degreesLat(geo.latitude);
        const lon = satellite.degreesLong(geo.longitude);
        const altMeters = Math.max(0, geo.height * 1000);
        satelliteAltitudes[s.name] = Math.max(0, geo.height);
        const color = getSatColor(s.name);
        const icon = getSatelliteIcon(s.name, color);
        if (!markers[s.name]) {
          const marker = L.marker([lat, lon], { icon }).addTo(mapInstance);
          marker.bindPopup(`<b>${s.name}</b><br>Lat: ${lat.toFixed(2)}¬∞<br>Lon: ${lon.toFixed(2)}¬∞<br>Alt: ${altMeters.toFixed(0)} m`);
          markers[s.name] = marker;
        } else {
          markers[s.name].setLatLng([lat, lon]);
          markers[s.name].setIcon(icon);
        }
        activeNames.add(s.name);
        const trackData = groundTracks[s.name];
        if (!trackData) {
          refreshGroundTrack(s.name, rec, color);
        }
      } catch (err) {
        /* ignore bad TLE entries */
      }
    });
    Object.keys(groundTracks).forEach(name => {
      if (!activeNames.has(name)) {
        groundTracks[name].layers.forEach(layer => mapInstance.removeLayer(layer));
        delete groundTracks[name];
      }
    });
    updateObserverCoverage();
  }

  setInterval(updateSatelliteMarkers, 2000);
});
</script>


  <!-- üåç Map Modal (final version) -->
  <div id="mapModal" style="display:none;opacity:0;visibility:hidden;position:fixed!important;inset:0;background:rgba(0,0,0,0.9)!important;z-index:999999!important;align-items:center;justify-content:center;transition:opacity 0.3s ease;">
    <div style="width:90%;height:90%;background:#0b1220;border-radius:12px;position:relative;box-shadow:0 0 20px rgba(0,0,0,0.6);">
      <div class="map-time-controls">
        <span class="map-time-label">Map Time (UTC)</span>
        <div class="map-time-row">
          <input type="datetime-local" id="mapTimeInput" step="1">
          <button id="mapJumpBtn">Go</button>
        </div>
        <div class="map-time-actions">
          <button id="mapPlayBtn">‚ñ∂Ô∏è Play</button>
          <button id="mapNowBtn">Live</button>
        </div>
        <div id="mapTimeStatus">Live mode</div>
      </div>
      <button id="closeMapBtn" aria-label="Close map" style="position:absolute;top:14px;right:18px;background:rgba(0,0,0,0.55);color:#fff;border:0;border-radius:999px;width:40px;height:40px;display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;z-index:100002!important;">‚úï</button>
      <div id="map" style="width:100%!important;height:100%!important;border-radius:12px;z-index:0;"></div>
    </div>
  </div>

</body>
</html>
